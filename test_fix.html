<!DOCTYPE html>
<html lang="zh-CN">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Extension Context ä¿®å¤æµ‹è¯•</title>
    <style>
        body {
            font-family: Arial, sans-serif;
            max-width: 1000px;
            margin: 0 auto;
            padding: 20px;
            line-height: 1.6;
        }
        .test-section {
            margin: 20px 0;
            padding: 20px;
            border: 2px solid #ddd;
            border-radius: 8px;
            background-color: #f9f9f9;
        }
        .status {
            padding: 15px;
            margin: 10px 0;
            border-radius: 5px;
            font-weight: bold;
        }
        .success { background-color: #d4edda; color: #155724; border: 1px solid #c3e6cb; }
        .error { background-color: #f8d7da; color: #721c24; border: 1px solid #f5c6cb; }
        .warning { background-color: #fff3cd; color: #856404; border: 1px solid #ffeaa7; }
        .info { background-color: #d1ecf1; color: #0c5460; border: 1px solid #bee5eb; }
        button {
            padding: 12px 24px;
            margin: 8px;
            border: none;
            border-radius: 6px;
            cursor: pointer;
            background-color: #007bff;
            color: white;
            font-size: 14px;
            font-weight: 500;
        }
        button:hover {
            background-color: #0056b3;
        }
        button:disabled {
            background-color: #6c757d;
            cursor: not-allowed;
        }
        .test-content {
            background-color: white;
            padding: 15px;
            border-radius: 5px;
            margin: 10px 0;
            border: 1px solid #dee2e6;
        }
        .log-output {
            background-color: #f8f9fa;
            padding: 15px;
            border-radius: 5px;
            max-height: 400px;
            overflow-y: auto;
            font-family: 'Courier New', monospace;
            font-size: 12px;
            border: 1px solid #dee2e6;
        }
        .log-entry {
            margin: 2px 0;
            padding: 2px 0;
        }
        .log-error { color: #dc3545; }
        .log-warning { color: #ffc107; }
        .log-success { color: #28a745; }
        .log-info { color: #17a2b8; }
    </style>
</head>
<body>
    <h1>ğŸ”§ Extension Context ä¿®å¤æµ‹è¯•</h1>
    <p><strong>æµ‹è¯•ç›®æ ‡ï¼š</strong>éªŒè¯Extension context invalidatedé”™è¯¯çš„ä¿®å¤æ•ˆæœï¼Œç‰¹åˆ«æ˜¯é’ˆå¯¹Qwen3æ¨¡å‹çš„ç¿»è¯‘åŠŸèƒ½ã€‚</p>
    
    <div class="test-section">
        <h2>ğŸ” æ‰©å±•çŠ¶æ€æ£€æŸ¥</h2>
        <div id="extension-status" class="status info">æ£€æŸ¥ä¸­...</div>
        <button onclick="checkExtensionStatus()">é‡æ–°æ£€æŸ¥æ‰©å±•çŠ¶æ€</button>
        <button onclick="testContextRecovery()">æµ‹è¯•ä¸Šä¸‹æ–‡æ¢å¤</button>
    </div>

    <div class="test-section">
        <h2>ğŸŒ ç¿»è¯‘åŠŸèƒ½æµ‹è¯•</h2>
        <div class="test-content">
            <p><strong>è‹±æ–‡æµ‹è¯•æ–‡æœ¬ï¼š</strong></p>
            <p>Hello, world! This is a test paragraph for translation. The quick brown fox jumps over the lazy dog.</p>
            
            <p><strong>æ—¥è¯­æµ‹è¯•æ–‡æœ¬ï¼š</strong></p>
            <p>ã“ã‚“ã«ã¡ã¯ä¸–ç•Œï¼ã“ã‚Œã¯ç¿»è¨³ã®ãŸã‚ã®ãƒ†ã‚¹ãƒˆæ®µè½ã§ã™ã€‚ã™ã¹ã¦ãŒæ­£å¸¸ã«å‹•ä½œã™ã‚‹ã“ã¨ã‚’é¡˜ã£ã¦ã„ã¾ã™ã€‚</p>
            
            <p><strong>éŸ©è¯­æµ‹è¯•æ–‡æœ¬ï¼š</strong></p>
            <p>ì•ˆë…•í•˜ì„¸ìš” ì„¸ê³„! ì´ê²ƒì€ ë²ˆì—­ì„ ìœ„í•œ í…ŒìŠ¤íŠ¸ ë‹¨ë½ì…ë‹ˆë‹¤. ëª¨ë“  ê²ƒì´ ì •ìƒì ìœ¼ë¡œ ì‘ë™í•˜ê¸°ë¥¼ ë°”ëë‹ˆë‹¤.</p>
        </div>
        
        <div>
            <button onclick="testSingleTranslation()">æµ‹è¯•å•ä¸ªç¿»è¯‘</button>
            <button onclick="testBatchTranslation()">æµ‹è¯•æ‰¹é‡ç¿»è¯‘</button>
            <button onclick="testQwen3Translation()">æµ‹è¯•Qwen3ç¿»è¯‘</button>
            <button onclick="testLongTextTranslation()">æµ‹è¯•é•¿æ–‡æœ¬ç¿»è¯‘</button>
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸš¨ é”™è¯¯å¤„ç†æµ‹è¯•</h2>
        <div>
            <button onclick="testTimeoutHandling()">æµ‹è¯•è¶…æ—¶å¤„ç†</button>
            <button onclick="testRetryMechanism()">æµ‹è¯•é‡è¯•æœºåˆ¶</button>
            <button onclick="testErrorRecovery()">æµ‹è¯•é”™è¯¯æ¢å¤</button>
            <button onclick="stressTest()">å‹åŠ›æµ‹è¯•</button>
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸ“Š æµ‹è¯•ç»“æœ</h2>
        <div id="test-results" class="status info">ç­‰å¾…æµ‹è¯•...</div>
        <div id="statistics" style="display: grid; grid-template-columns: repeat(4, 1fr); gap: 10px; margin-top: 10px;">
            <div class="status info">æˆåŠŸ: <span id="success-count">0</span></div>
            <div class="status warning">å¤±è´¥: <span id="failure-count">0</span></div>
            <div class="status error">é”™è¯¯: <span id="error-count">0</span></div>
            <div class="status success">æ€»è®¡: <span id="total-count">0</span></div>
        </div>
    </div>

    <div class="test-section">
        <h2>ğŸ“ è¯¦ç»†æ—¥å¿—</h2>
        <div id="log-output" class="log-output"></div>
        <div>
            <button onclick="clearLog()">æ¸…é™¤æ—¥å¿—</button>
            <button onclick="exportLog()">å¯¼å‡ºæ—¥å¿—</button>
        </div>
    </div>

    <script>
        // æµ‹è¯•ç»Ÿè®¡
        let testStats = {
            success: 0,
            failure: 0,
            error: 0,
            total: 0
        };

        // æ—¥å¿—åŠŸèƒ½
        function log(message, type = 'info') {
            const logOutput = document.getElementById('log-output');
            const timestamp = new Date().toLocaleTimeString();
            const logEntry = document.createElement('div');
            logEntry.className = `log-entry log-${type}`;
            logEntry.textContent = `[${timestamp}] ${message}`;
            logOutput.appendChild(logEntry);
            logOutput.scrollTop = logOutput.scrollHeight;

            // æ›´æ–°ç»Ÿè®¡
            if (type === 'success') testStats.success++;
            else if (type === 'warning') testStats.failure++;
            else if (type === 'error') testStats.error++;
            testStats.total++;
            updateStatistics();
        }

        function updateStatistics() {
            document.getElementById('success-count').textContent = testStats.success;
            document.getElementById('failure-count').textContent = testStats.failure;
            document.getElementById('error-count').textContent = testStats.error;
            document.getElementById('total-count').textContent = testStats.total;
        }

        function clearLog() {
            document.getElementById('log-output').innerHTML = '';
            testStats = { success: 0, failure: 0, error: 0, total: 0 };
            updateStatistics();
        }

        function exportLog() {
            const logOutput = document.getElementById('log-output');
            const logText = logOutput.innerText;
            const blob = new Blob([logText], { type: 'text/plain' });
            const url = URL.createObjectURL(blob);
            const a = document.createElement('a');
            a.href = url;
            a.download = `extension-test-log-${Date.now()}.txt`;
            a.click();
            URL.revokeObjectURL(url);
        }

        // æ£€æŸ¥æ‰©å±•çŠ¶æ€
        function checkExtensionStatus() {
            const statusDiv = document.getElementById('extension-status');
            
            try {
                if (typeof chrome !== 'undefined' && chrome.runtime && chrome.runtime.id) {
                    statusDiv.className = 'status success';
                    statusDiv.textContent = 'âœ… æ‰©å±•ä¸Šä¸‹æ–‡æ­£å¸¸ - ID: ' + chrome.runtime.id;
                    log('æ‰©å±•ä¸Šä¸‹æ–‡æ£€æŸ¥æˆåŠŸ', 'success');
                    return true;
                } else {
                    statusDiv.className = 'status error';
                    statusDiv.textContent = 'âŒ æ‰©å±•ä¸Šä¸‹æ–‡æ— æ•ˆ';
                    log('æ‰©å±•ä¸Šä¸‹æ–‡æ£€æŸ¥å¤±è´¥', 'error');
                    return false;
                }
            } catch (error) {
                statusDiv.className = 'status error';
                statusDiv.textContent = 'âŒ æ‰©å±•ä¸Šä¸‹æ–‡æ£€æŸ¥å‡ºé”™: ' + error.message;
                log('æ‰©å±•ä¸Šä¸‹æ–‡æ£€æŸ¥å¼‚å¸¸: ' + error.message, 'error');
                return false;
            }
        }

        // æµ‹è¯•ä¸Šä¸‹æ–‡æ¢å¤
        async function testContextRecovery() {
            log('å¼€å§‹æµ‹è¯•ä¸Šä¸‹æ–‡æ¢å¤æœºåˆ¶...', 'info');
            
            // æ¨¡æ‹Ÿå¤šæ¬¡æ£€æŸ¥
            for (let i = 0; i < 5; i++) {
                await new Promise(resolve => setTimeout(resolve, 1000));
                const isValid = checkExtensionStatus();
                if (isValid) {
                    log(`ä¸Šä¸‹æ–‡æ£€æŸ¥ ${i + 1}/5: æ­£å¸¸`, 'success');
                } else {
                    log(`ä¸Šä¸‹æ–‡æ£€æŸ¥ ${i + 1}/5: å¼‚å¸¸`, 'error');
                }
            }
        }

        // æµ‹è¯•å•ä¸ªç¿»è¯‘
        async function testSingleTranslation() {
            log('å¼€å§‹æµ‹è¯•å•ä¸ªç¿»è¯‘...', 'info');
            
            if (!checkExtensionStatus()) {
                log('æ‰©å±•ä¸Šä¸‹æ–‡æ— æ•ˆï¼Œè·³è¿‡ç¿»è¯‘æµ‹è¯•', 'error');
                return;
            }

            try {
                const result = await sendTranslationRequest('Hello, world!', {
                    aiModel: 'openai-gpt35',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key'
                });
                
                if (result.success) {
                    log('å•ä¸ªç¿»è¯‘æµ‹è¯•æˆåŠŸ: ' + result.translation, 'success');
                } else {
                    log('å•ä¸ªç¿»è¯‘æµ‹è¯•å¤±è´¥: ' + result.error, 'warning');
                }
            } catch (error) {
                log('å•ä¸ªç¿»è¯‘æµ‹è¯•å¼‚å¸¸: ' + error.message, 'error');
            }
        }

        // æµ‹è¯•Qwen3ç¿»è¯‘
        async function testQwen3Translation() {
            log('å¼€å§‹æµ‹è¯•Qwen3ç¿»è¯‘ï¼ˆé¢„æœŸä¼šå› ä¸ºæ— æ•ˆAPI Keyè€Œå¤±è´¥ï¼Œä½†åº”è¯¥æœ‰æ­£ç¡®çš„é”™è¯¯å¤„ç†ï¼‰...', 'info');
            
            if (!checkExtensionStatus()) {
                log('æ‰©å±•ä¸Šä¸‹æ–‡æ— æ•ˆï¼Œè·³è¿‡Qwen3ç¿»è¯‘æµ‹è¯•', 'error');
                return;
            }

            try {
                const result = await sendTranslationRequest('Hello, this is a test for Qwen3.', {
                    aiModel: 'qwen3',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key-qwen3'
                });
                
                if (result.success) {
                    log('Qwen3ç¿»è¯‘æµ‹è¯•æ„å¤–æˆåŠŸ: ' + result.translation, 'success');
                } else {
                    log('Qwen3ç¿»è¯‘æµ‹è¯•å¦‚é¢„æœŸå¤±è´¥: ' + result.error, 'info');
                }
            } catch (error) {
                log('Qwen3ç¿»è¯‘æµ‹è¯•å¼‚å¸¸: ' + error.message, 'warning');
            }
        }

        // æµ‹è¯•æ‰¹é‡ç¿»è¯‘
        async function testBatchTranslation() {
            log('å¼€å§‹æµ‹è¯•æ‰¹é‡ç¿»è¯‘...', 'info');
            
            const testTexts = [
                'First test sentence.',
                'Second test sentence.',
                'Third test sentence.',
                'Fourth test sentence.',
                'Fifth test sentence.'
            ];

            for (let i = 0; i < testTexts.length; i++) {
                if (!checkExtensionStatus()) {
                    log('æ‰¹é‡ç¿»è¯‘è¿‡ç¨‹ä¸­æ£€æµ‹åˆ°æ‰©å±•ä¸Šä¸‹æ–‡å¤±æ•ˆ', 'error');
                    break;
                }

                try {
                    const result = await sendTranslationRequest(testTexts[i], {
                        aiModel: 'openai-gpt35',
                        sourceLang: 'en',
                        targetLang: 'zh',
                        apiKey: 'test-key'
                    });
                    
                    if (result.success) {
                        log(`æ‰¹é‡ç¿»è¯‘ ${i + 1}/${testTexts.length} æˆåŠŸ`, 'success');
                    } else {
                        log(`æ‰¹é‡ç¿»è¯‘ ${i + 1}/${testTexts.length} å¤±è´¥: ${result.error}`, 'warning');
                    }
                } catch (error) {
                    log(`æ‰¹é‡ç¿»è¯‘ ${i + 1}/${testTexts.length} å¼‚å¸¸: ${error.message}`, 'error');
                }

                // çŸ­æš‚å»¶è¿Ÿ
                await new Promise(resolve => setTimeout(resolve, 500));
            }
        }

        // æµ‹è¯•é•¿æ–‡æœ¬ç¿»è¯‘
        async function testLongTextTranslation() {
            log('å¼€å§‹æµ‹è¯•é•¿æ–‡æœ¬ç¿»è¯‘...', 'info');
            
            const longText = 'This is a very long text for testing translation functionality. '.repeat(50);
            
            try {
                const result = await sendTranslationRequest(longText, {
                    aiModel: 'qwen3',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key'
                });
                
                if (result.success) {
                    log('é•¿æ–‡æœ¬ç¿»è¯‘æµ‹è¯•æˆåŠŸ', 'success');
                } else {
                    log('é•¿æ–‡æœ¬ç¿»è¯‘æµ‹è¯•å¤±è´¥: ' + result.error, 'warning');
                }
            } catch (error) {
                log('é•¿æ–‡æœ¬ç¿»è¯‘æµ‹è¯•å¼‚å¸¸: ' + error.message, 'error');
            }
        }

        // æµ‹è¯•è¶…æ—¶å¤„ç†
        async function testTimeoutHandling() {
            log('å¼€å§‹æµ‹è¯•è¶…æ—¶å¤„ç†...', 'info');
            
            try {
                // å‘é€ä¸€ä¸ªå¯èƒ½è¶…æ—¶çš„è¯·æ±‚
                const result = await sendTranslationRequest('Test timeout handling', {
                    aiModel: 'qwen3',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'invalid-key-for-timeout-test'
                });
                
                log('è¶…æ—¶å¤„ç†æµ‹è¯•ç»“æœ: ' + (result.success ? 'æˆåŠŸ' : result.error), result.success ? 'success' : 'info');
            } catch (error) {
                log('è¶…æ—¶å¤„ç†æµ‹è¯•å¼‚å¸¸: ' + error.message, 'warning');
            }
        }

        // æµ‹è¯•é‡è¯•æœºåˆ¶
        async function testRetryMechanism() {
            log('å¼€å§‹æµ‹è¯•é‡è¯•æœºåˆ¶...', 'info');
            
            // å¿«é€Ÿå‘é€å¤šä¸ªè¯·æ±‚æ¥æµ‹è¯•é‡è¯•
            const promises = [];
            for (let i = 0; i < 3; i++) {
                promises.push(sendTranslationRequest(`Retry test ${i + 1}`, {
                    aiModel: 'openai-gpt35',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key'
                }));
            }

            try {
                const results = await Promise.allSettled(promises);
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled') {
                        log(`é‡è¯•æµ‹è¯• ${index + 1}: ${result.value.success ? 'æˆåŠŸ' : 'å¤±è´¥'}`, result.value.success ? 'success' : 'warning');
                    } else {
                        log(`é‡è¯•æµ‹è¯• ${index + 1}: å¼‚å¸¸ - ${result.reason.message}`, 'error');
                    }
                });
            } catch (error) {
                log('é‡è¯•æœºåˆ¶æµ‹è¯•å¼‚å¸¸: ' + error.message, 'error');
            }
        }

        // æµ‹è¯•é”™è¯¯æ¢å¤
        async function testErrorRecovery() {
            log('å¼€å§‹æµ‹è¯•é”™è¯¯æ¢å¤...', 'info');
            
            // å…ˆå‘é€ä¸€ä¸ªé¢„æœŸå¤±è´¥çš„è¯·æ±‚
            try {
                await sendTranslationRequest('Error recovery test', {
                    aiModel: 'invalid-model',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'invalid-key'
                });
            } catch (error) {
                log('é¢„æœŸé”™è¯¯å‘ç”Ÿ: ' + error.message, 'info');
            }

            // ç„¶åå‘é€ä¸€ä¸ªæ­£å¸¸çš„è¯·æ±‚ï¼Œæµ‹è¯•æ˜¯å¦èƒ½æ¢å¤
            await new Promise(resolve => setTimeout(resolve, 1000));
            
            try {
                const result = await sendTranslationRequest('Recovery test', {
                    aiModel: 'openai-gpt35',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key'
                });
                
                log('é”™è¯¯æ¢å¤æµ‹è¯•: ' + (result.success ? 'æˆåŠŸæ¢å¤' : 'æ¢å¤å¤±è´¥'), result.success ? 'success' : 'warning');
            } catch (error) {
                log('é”™è¯¯æ¢å¤æµ‹è¯•å¼‚å¸¸: ' + error.message, 'error');
            }
        }

        // å‹åŠ›æµ‹è¯•
        async function stressTest() {
            log('å¼€å§‹å‹åŠ›æµ‹è¯•ï¼ˆ10ä¸ªå¹¶å‘è¯·æ±‚ï¼‰...', 'info');
            
            const promises = [];
            for (let i = 0; i < 10; i++) {
                promises.push(sendTranslationRequest(`Stress test ${i + 1}`, {
                    aiModel: 'openai-gpt35',
                    sourceLang: 'en',
                    targetLang: 'zh',
                    apiKey: 'test-key'
                }));
            }

            try {
                const results = await Promise.allSettled(promises);
                let successCount = 0;
                let failureCount = 0;
                
                results.forEach((result, index) => {
                    if (result.status === 'fulfilled' && result.value.success) {
                        successCount++;
                    } else {
                        failureCount++;
                    }
                });
                
                log(`å‹åŠ›æµ‹è¯•å®Œæˆ: ${successCount}æˆåŠŸ, ${failureCount}å¤±è´¥`, 'info');
                
                if (successCount > 0) {
                    log('å‹åŠ›æµ‹è¯•ï¼šæ‰©å±•åœ¨å¹¶å‘è¯·æ±‚ä¸‹è¡¨ç°æ­£å¸¸', 'success');
                } else {
                    log('å‹åŠ›æµ‹è¯•ï¼šæ‰©å±•åœ¨å¹¶å‘è¯·æ±‚ä¸‹å‡ºç°é—®é¢˜', 'warning');
                }
            } catch (error) {
                log('å‹åŠ›æµ‹è¯•å¼‚å¸¸: ' + error.message, 'error');
            }
        }

        // å‘é€ç¿»è¯‘è¯·æ±‚çš„è¾…åŠ©å‡½æ•°
        function sendTranslationRequest(text, settings) {
            return new Promise((resolve, reject) => {
                if (!chrome.runtime?.id) {
                    reject(new Error('Extension context invalid'));
                    return;
                }

                const timeout = setTimeout(() => {
                    reject(new Error('Request timeout'));
                }, 10000);

                chrome.runtime.sendMessage({
                    action: 'translate',
                    text: text,
                    settings: settings
                }, (response) => {
                    clearTimeout(timeout);
                    
                    if (chrome.runtime.lastError) {
                        reject(new Error(chrome.runtime.lastError.message));
                    } else {
                        resolve(response || { success: false, error: 'No response' });
                    }
                });
            });
        }

        // é¡µé¢åŠ è½½æ—¶æ£€æŸ¥æ‰©å±•çŠ¶æ€
        window.addEventListener('load', () => {
            log('æµ‹è¯•é¡µé¢åŠ è½½å®Œæˆ', 'info');
            checkExtensionStatus();
            
            // æ¯5ç§’è‡ªåŠ¨æ£€æŸ¥ä¸€æ¬¡æ‰©å±•çŠ¶æ€
            setInterval(() => {
                if (document.hasFocus()) {
                    checkExtensionStatus();
                }
            }, 5000);
        });

        // ç›‘å¬æ¥è‡ªæ‰©å±•çš„æ¶ˆæ¯
        if (typeof chrome !== 'undefined' && chrome.runtime) {
            chrome.runtime.onMessage.addListener((message, sender, sendResponse) => {
                log('æ”¶åˆ°æ‰©å±•æ¶ˆæ¯: ' + JSON.stringify(message), 'info');
                sendResponse({ received: true });
            });
        }
    </script>
</body>
</html>